/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/google/apis-client-generator/
 * Modify at your own risk.
 */
module Google.Apis.Drive.v3.DriveRequest;

import requests;
import url;
import std.typecons: Nullable;
import std.conv: to;
import vibe.data.json;
import std.json;

/**
 * Drive request.
 */
public class DriveRequest(
  RequestT = Request,
  ResponseT = Response,
  string HttpMethod = "GET",
  RequestType = Object,
  ResponseType = Object,
  MediaContentType = string) {
  private static const ulong KB = 0x10000;

  private static const DEFAULT_CHUNK_SIZE = 256 * KB;

  RequestT request;
  URL url;
  string restPath;
  RequestType content;
  MediaContentType mediaContent;

  public this(string restPath, string urlString) {
    this.restPath = restPath;

    url = (urlString ~ restPath).parseURL;
  }

  private ulong chunkSize = DEFAULT_CHUNK_SIZE;
  public auto setChunkSize(ulong chunkSize) {
    this.chunkSize = chunkSize;
    return this;
  }

  public ulong getChunkSize() {
    return this.chunkSize;
  }

  /** Data format for the response. */
  private string alt;

  /**
   * Data format for the response. [default: json]
   */
  public string getAlt() {
    return alt;
  }

  /** Data format for the response. */
  public auto setAlt(string alt) {
    this.alt = alt;
    set!(string)("alt", alt);
    return this;
  }
  /** Selector specifying which fields to include in a partial response. */
  private string fields;

  /**
   * Selector specifying which fields to include in a partial response.
   */
  public string getFields() {
    return fields;
  }

  /** Selector specifying which fields to include in a partial response. */
  public auto setFields(string fields) {
    this.fields = fields;
    set!(string)("fields", fields);
    return this;
  }
  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  private string key;

  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  public string getKey() {
    return key;
  }

  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  public auto setKey(string key) {
    this.key = key;
    set!(string)("key", key);
    return this;
  }
  /** OAuth 2.0 token for the current user. */
  private string oauthToken;

  /**
   * OAuth 2.0 token for the current user.
   */
  public string getOauthToken() {
    return oauthToken;
  }

  /** OAuth 2.0 token for the current user. */
  public auto setOauthToken(string oauthToken) {
    this.oauthToken = oauthToken;
    set!(string)("oauthToken", oauthToken);
    return this;
  }
  /** Returns response with indentations and line breaks. */
  private Nullable!bool prettyPrint;

  /**
   * Returns response with indentations and line breaks. [default: true]
   */
  public Nullable!bool getPrettyPrint() {
    return prettyPrint;
  }

  /** Returns response with indentations and line breaks. */
  public auto setPrettyPrint(Nullable!bool prettyPrint) {
    this.prettyPrint = prettyPrint;
    set!(Nullable!bool)("prettyPrint", prettyPrint);
    return this;
  }
  /** An opaque string that represents a user for quota purposes. Must not exceed 40 characters. */
  private string quotaUser;

  /**
   * An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
   */
  public string getQuotaUser() {
    return quotaUser;
  }

  /** An opaque string that represents a user for quota purposes. Must not exceed 40 characters. */
  public auto setQuotaUser(string quotaUser) {
    this.quotaUser = quotaUser;
    set!(string)("quotaUser", quotaUser);
    return this;
  }
  /** Deprecated. Please use quotaUser instead. */
  private string userIp;

  /**
   * Deprecated. Please use quotaUser instead.
   */
  public string getUserIp() {
    return userIp;
  }

  /** Deprecated. Please use quotaUser instead. */
  public auto setUserIp(string userIp) {
    this.userIp = userIp;
    set!(string)("userIp", userIp);
    return this;
  }

  public void set(T)(string parameterName, auto ref T value) {
    url.queryParams.add(parameterName, to!string(value));
  }

  private Json getInitializedFields(Json json) {
    Json ret = Json.emptyObject;

    foreach (jkey, jvalue; json.byKeyValue) {
      Json temp = jvalue.type == Json.Type.object ? getInitializedFields(jvalue) : Json("");
      if (temp == Json.emptyObject) continue;
      if (temp != Json("") && jvalue.type == Json.Type.object) {
        ret[jkey[1..$]] = temp;
      } else if (jvalue.type != Json.Type.null_ && jvalue != Json("") && jvalue != Json.emptyArray) {
        ret[jkey[1..$]] = jvalue;
      }
    }

    return ret;
  }

  private Json serializeModelToJson(T) (
    auto ref T value
  ) {
    return getInitializedFields(value.serializeToJson());
  }

  private T deserializeJsonToModel(T) (
    ref Json json
  ) {
    string str = json.toString;

    import std.regex;
    auto re = regex("[a-zA-Z./]+\":");
    str = replaceAll(str, re, "_$&");

    json = str.serializeToJson();

    return json.deserializeJson!T();
  }

  import std.stdio: File;
  private ResponseType doResumableUpload(string InitialHttpMethod)() {
    set("uploadType", "resumable");

    request.addHeaders([
      "Authorization": "Bearer " ~ oauthToken,
      "Content-Type": "application/json"
    ]);

    string metadata = content is RequestType.init ? "" : serializeModelToJson(content).toString;
  //import std.stdio;
    auto response = request.exec!HttpMethod(url, metadata);
    //writeln(HttpMethod);
    //writeln(response.responseBody);
    //writeln(url);
    //writeln(metadata);
    string location = response.responseHeaders["location"];

    //writeln(location);

    ResponseType responseContent;

    static if (is(MediaContentType == string)) {
      request.addHeaders([
        "Content-Range": "bytes 0-" ~ to!string(mediaContent.length - 1) ~ "/" ~ to!string(mediaContent.length)
      ]);
//writeln(mediaContent);
      response = request.exec!"PUT"(location, mediaContent);
 //     writeln(response.code);
 //     writeln(response.responseBody);
    } else static if (is(MediaContentType == File)) {
      ulong totalRead = 0;
      ulong fileSize = mediaContent.size;

      foreach (ubyte[] buffer; mediaContent.byChunk(chunkSize)) {
        request.clearHeaders();
        totalRead += buffer.length;
        request.addHeaders([
          "Content-Range": "bytes " ~ to!(string)(totalRead - buffer.length) ~  "-" ~ to!(string)(totalRead - 1) ~ "/" ~ to!(string)(fileSize),
          "Content-Length": to!(string)(buffer.length)
        ]);

        response = request.exec!"PUT"(location, buffer);

      }
    }
    string resString = response.responseBody.toString;

    import std.regex;
    auto re = regex("[a-zA-Z./]+\":");
    resString = replaceAll(resString, re, "_$&");

    Json resJson = parseJSON(resString).serializeToJson();
    responseContent = resJson.deserializeJson!ResponseType();

    return responseContent;
  }

  public ResponseType upload() {
    return doResumableUpload!HttpMethod();
  }

  public ResponseType execute() {
    string metadata = is(RequestType == Object) ? "" : serializeModelToJson(content).toString;

    request.addHeaders([
      "Authorization": "Bearer " ~ oauthToken,
      "Content-Type": "application/json"
    ]);

    ResponseT res = request.exec!HttpMethod(url, metadata);

    static if (!is(ResponseType == Object)) {
      ResponseType response;
      string resString = res.responseBody.toString;

      import std.regex;
      auto re = regex("[a-zA-Z./]+\":");
      resString = replaceAll(resString, re, "_$&");

      Json resJson = parseJSON(resString).serializeToJson();
      response = resJson.deserializeJson!ResponseType();

      return response;
    } else {
      return new ResponseType();
    }
  }
}
